<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Menús para Juegos - Generador de JSON</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 10px; 
            background-color: #f0f0f0;
        }
        #container { 
            display: flex; 
            height: 100vh; 
            gap: 10px;
        }
        #canvasContainer { 
            border: 1px solid #333; 
            overflow: auto; 
            flex: 1; 
            max-width: calc(100vw - 320px);
            background-color: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border-radius: 4px;
        }
        #canvas { 
            display: block; 
            border: 1px solid #ddd; 
            cursor: default;
            background-color: #f9f9f9;
        }
        #controls { 
            width: 300px; 
            padding: 15px; 
            overflow-y: auto;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .viewBtn { 
            margin: 5px 0; 
            padding: 8px 12px; 
            width: 100%;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .viewBtn:hover {
            background-color: #3a5a8a;
        }
        #urlInput { 
            width: 100%; 
            margin-bottom: 5px; 
            padding: 8px; 
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button { 
            margin: 2px; 
            padding: 8px; 
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #imageList div { 
            margin-bottom: 10px; 
            border: 1px solid #ddd; 
            padding: 8px; 
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        #imageList input { 
            width: 150px; 
            margin-right: 5px; 
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .toolBtn { 
            width: 100%; 
            margin: 5px 0; 
        }
        input[type="radio"] { 
            margin-right: 5px; 
        }
        #fileInput { 
            display: none; 
        }
        .actionBtn { 
            width: 100%; 
            margin: 5px 0; 
            padding: 10px;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .actionBtn:hover {
            background-color: #4cae4c;
        }
        .gif-indicator {
            display: inline-block;
            background-color: #5cb85c;
            color: white;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }
        h3 {
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .selected {
            background-color: #e6f3ff;
            border-color: #4a90e2;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <h3>Vista</h3>
            <button class="viewBtn" onclick="setView('pc')">PC Horizontal (1920x1080)</button>
            <button class="viewBtn" onclick="setView('mobileH')">Móvil Horizontal (800x480)</button>
            <button class="viewBtn" onclick="setView('mobileV')">Móvil Vertical (480x800)</button>
            
            <h3>Herramientas</h3>
            <label><input type="radio" name="tool" value="modificador" checked onchange="selectTool('modificador')"> Modificador</label><br>
            <label><input type="radio" name="tool" value="zoom" onchange="selectTool('zoom')"> Zoom de Imagen</label>
            
            <h3>Añadir Imagen</h3>
            <input type="text" id="urlInput" placeholder="Colocar URL de la imagen (GIF, PNG, etc.)">
            <button onclick="loadImage()" style="width: 100%;">Cargar Imagen</button>
            
            <h3>Cuadros <span id="imageCount">(0)</span></h3>
            <div id="imageList"></div>
            
            <button onclick="saveJSON()" class="actionBtn">Guardar JSON</button>
            <input type="file" id="fileInput" accept=".json" onchange="importJSON(event)">
            <button onclick="document.getElementById('fileInput').click()" class="actionBtn">Importar JSON</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let images = [];
        let currentView = 'pc';
        let zoom = 1;
        let selectedImage = null;
        let currentTool = 'modificador';
        let mode = 'none';
        let startX, startY;
        let logicalW, logicalH;
        let pivotRelX, pivotRelY, initialDist;
        let animationFrameId = null;

        const views = {
            'pc': { w: 1920, h: 1080 },
            'mobileH': { w: 800, h: 480 },
            'mobileV': { w: 480, h: 800 }
        };

        function selectTool(tool) {
            currentTool = tool;
            mode = 'none';
            canvas.style.cursor = 'default';
            draw();
        }

        function setView(viewName) {
            currentView = viewName;
            zoom = 1;
            updateCanvasSize();
            updateList();
        }

        function updateCanvasSize() {
            logicalW = views[currentView].w;
            logicalH = views[currentView].h;
            const displayW = logicalW * zoom;
            const displayH = logicalH * zoom;
            canvas.width = displayW;
            canvas.height = displayH;
            canvas.style.width = displayW + 'px';
            canvas.style.height = displayH + 'px';
            draw();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scale = zoom;
            return {
                x: (e.clientX - rect.left) / scale,
                y: (e.clientY - rect.top) / scale
            };
        }

        function getLogicalPosFromPercent(percentX, percentY) {
            return {
                x: (percentX / 100) * logicalW,
                y: (percentY / 100) * logicalH
            };
        }

        function getImageAt(mx, my) {
            for (let i = images.length - 1; i >= 0; i--) {
                const img = images[i];
                if (!img.img || !img.img.complete) continue;
                const { x: left, y: top } = getLogicalPosFromPercent(img.x, img.y);
                const width = (img.ancho / 100) * logicalW;
                const height = (img.alto / 100) * logicalH;
                const right = left + width;
                const bottom = top + height;
                if (mx >= left && mx <= right && my >= top && bottom >= my) {
                    return img;
                }
            }
            return null;
        }

        function getHandleAt(img, mx, my) {
            const handleScreenSize = 10;
            const logicalHandleSize = handleScreenSize / zoom;
            const half = logicalHandleSize / 2;
            const { x: left, y: top } = getLogicalPosFromPercent(img.x, img.y);
            const width = (img.ancho / 100) * logicalW;
            const height = (img.alto / 100) * logicalH;
            const right = left + width;
            const bottom = top + height;

            if (mx >= left - half && mx <= left + half && my >= top - half && my <= top + half) return 'nw';
            if (mx >= right - half && mx <= right + half && my >= top - half && my <= top + half) return 'ne';
            if (mx >= left - half && mx <= left + half && my >= bottom - half && my <= bottom + half) return 'sw';
            if (mx >= right - half && mx <= right + half && my >= bottom - half && my <= bottom + half) return 'se';
            return null;
        }

        function getCursorForHandle(handle) {
            return (handle === 'nw' || handle === 'se') ? 'nwse-resize' : 'nesw-resize';
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            if (currentTool === 'zoom') {
                selectedImage = getImageAt(pos.x, pos.y);
                if (!selectedImage) return;
                mode = 'zoom';
                const { x: left, y: top } = getLogicalPosFromPercent(selectedImage.x, selectedImage.y);
                const width = (selectedImage.ancho / 100) * logicalW;
                const height = (selectedImage.alto / 100) * logicalH;
                pivotRelX = (pos.x - left) / width;
                pivotRelY = (pos.y - top) / height;
                startX = pos.x;
                startY = pos.y;
                initialDist = Math.sqrt((pos.x - startX)**2 + (pos.y - startY)**2);
                canvas.style.cursor = 'zoom-in';
            } else {
                selectedImage = getImageAt(pos.x, pos.y);
                if (!selectedImage) {
                    mode = 'none';
                    draw();
                    return;
                }
                const handle = getHandleAt(selectedImage, pos.x, pos.y);
                mode = handle || 'drag';
                startX = pos.x;
                startY = pos.y;
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            if (mode !== 'none') {
                if (currentTool === 'zoom' && mode === 'zoom') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const currentDist = Math.sqrt(dx*dx + dy*dy);
                    let scale = 1;
                    if (initialDist > 0) {
                        scale = currentDist / initialDist;
                    } else {
                        scale = 1 + (currentDist / 100);
                    }
                    if (scale < 0.1) scale = 0.1;
                    const oldWidth = (selectedImage.ancho / 100) * logicalW;
                    const oldHeight = (selectedImage.alto / 100) * logicalH;
                    const newWidth = oldWidth * scale;
                    const newHeight = oldHeight * scale;
                    const newLeft = startX - pivotRelX * newWidth;
                    const newTop = startY - pivotRelY * newHeight;
                    selectedImage.x = (newLeft / logicalW) * 100;
                    selectedImage.y = (newTop / logicalH) * 100;
                    selectedImage.ancho = (newWidth / logicalW) * 100;
                    selectedImage.alto = (newHeight / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    initialDist = currentDist;
                    draw();
                } else if (mode === 'drag') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedImage.x, selectedImage.y);
                    selectedImage.x = ((origLeft + dx) / logicalW) * 100;
                    selectedImage.y = ((origTop + dy) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'nw') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedImage.x, selectedImage.y);
                    const origRight = origLeft + (selectedImage.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedImage.alto / 100) * logicalH;
                    const newLeft = origLeft + dx;
                    const newTop = origTop + dy;
                    selectedImage.x = (newLeft / logicalW) * 100;
                    selectedImage.y = (newTop / logicalH) * 100;
                    selectedImage.ancho = ((origRight - newLeft) / logicalW) * 100;
                    selectedImage.alto = ((origBottom - newTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'ne') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedImage.x, selectedImage.y);
                    const origRight = origLeft + (selectedImage.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedImage.alto / 100) * logicalH;
                    const newRight = origRight + dx;
                    const newTop = origTop + dy;
                    selectedImage.y = (newTop / logicalH) * 100;
                    selectedImage.ancho = ((newRight - origLeft) / logicalW) * 100;
                    selectedImage.alto = ((origBottom - newTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'sw') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedImage.x, selectedImage.y);
                    const origRight = origLeft + (selectedImage.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedImage.alto / 100) * logicalH;
                    const newLeft = origLeft + dx;
                    const newBottom = origBottom + dy;
                    selectedImage.x = (newLeft / logicalW) * 100;
                    selectedImage.ancho = ((origRight - newLeft) / logicalW) * 100;
                    selectedImage.alto = ((newBottom - origTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'se') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedImage.x, selectedImage.y);
                    const origRight = origLeft + (selectedImage.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedImage.alto / 100) * logicalH;
                    const newRight = origRight + dx;
                    const newBottom = origBottom + dy;
                    selectedImage.ancho = ((newRight - origLeft) / logicalW) * 100;
                    selectedImage.alto = ((newBottom - origTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                }
            } else {
                if (currentTool === 'zoom') {
                    const img = getImageAt(pos.x, pos.y);
                    canvas.style.cursor = img ? 'zoom-in' : 'default';
                } else {
                    const img = getImageAt(pos.x, pos.y);
                    if (img) {
                        const handle = getHandleAt(img, pos.x, pos.y);
                        if (handle) {
                            canvas.style.cursor = getCursorForHandle(handle);
                        } else {
                            canvas.style.cursor = 'move';
                        }
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            mode = 'none';
            if (currentTool === 'zoom') {
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const pos = getMousePos(e);
            const img = getImageAt(pos.x, pos.y);
            if (!img) return;
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoom = Math.max(0.5, Math.min(3, zoom + delta));
            updateCanvasSize();
        });

        function draw() {
            // Cancelar el frame de animación anterior si existe
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar todas las imágenes
            images.forEach(img => {
                if (!img.img || !img.img.complete) return;
                
                const px = (img.x / 100) * logicalW * zoom;
                const py = (img.y / 100) * logicalH * zoom;
                const pw = (img.ancho / 100) * logicalW * zoom;
                const ph = (img.alto / 100) * logicalH * zoom;
                
                ctx.drawImage(img.img, px, py, pw, ph);
            });
            
            // Dibujar bordes y controles para la imagen seleccionada
            if (selectedImage) {
                const px = (selectedImage.x / 100) * logicalW * zoom;
                const py = (selectedImage.y / 100) * logicalH * zoom;
                const pw = (selectedImage.ancho / 100) * logicalW * zoom;
                const ph = (selectedImage.alto / 100) * logicalH * zoom;
                
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 2;
                ctx.strokeRect(px, py, pw, ph);
                
                const hs = 10;
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(px - hs / 2, py - hs / 2, hs, hs);
                ctx.fillRect(px + pw - hs / 2, py - hs / 2, hs, hs);
                ctx.fillRect(px - hs / 2, py + ph - hs / 2, hs, hs);
                ctx.fillRect(px + pw - hs / 2, py + ph - hs / 2, hs, hs);
            }
            
            // Programar el siguiente frame para animaciones
            animationFrameId = requestAnimationFrame(draw);
        }

        function loadImage() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) {
                alert('Por favor, introduce una URL válida');
                return;
            }
            
            const newImgData = {
                name: `cuadro ${images.length + 1}`,
                x: 40,
                y: 40,
                ancho: 20,
                alto: 20,
                url: url,
                img: new Image(),
                isGif: url.toLowerCase().endsWith('.gif')
            };
            
            newImgData.img.crossOrigin = 'anonymous';
            newImgData.img.onload = () => {
                draw();
                updateList();
            };
            newImgData.img.onerror = () => {
                alert('Error al cargar la imagen. Verifica la URL y que no tenga restricciones CORS.');
                // Eliminar la imagen de la lista si falla la carga
                const index = images.indexOf(newImgData);
                if (index > -1) {
                    images.splice(index, 1);
                    updateList();
                }
            };
            newImgData.img.src = url;
            images.push(newImgData);
            selectedImage = newImgData;
            document.getElementById('urlInput').value = '';
            draw();
            updateList();
        }

        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    if (!jsonData.nombre || !jsonData.cuadros || !Array.isArray(jsonData.cuadros)) {
                        throw new Error('Formato JSON inválido');
                    }
                    
                    // Limpiar imágenes anteriores
                    images.forEach(img => {
                        if (img.img) {
                            img.img.src = ''; // Liberar recursos
                        }
                    });
                    
                    images = [];
                    selectedImage = null;
                    
                    // Cargar nuevas imágenes
                    jsonData.cuadros.forEach(cuadro => {
                        const imgData = {
                            name: cuadro.nombre || `cuadro ${images.length + 1}`,
                            x: cuadro.x || 0,
                            y: cuadro.y || 0,
                            ancho: cuadro.ancho || 20,
                            alto: cuadro.alto || 20,
                            url: cuadro.url || '',
                            img: new Image(),
                            isGif: (cuadro.url || '').toLowerCase().endsWith('.gif')
                        };
                        
                        imgData.img.crossOrigin = 'anonymous';
                        imgData.img.onload = () => {
                            draw();
                            updateList();
                        };
                        imgData.img.onerror = () => {
                            console.warn(`No se pudo cargar la imagen: ${imgData.url}`);
                        };
                        imgData.img.src = imgData.url;
                        images.push(imgData);
                    });
                    
                    draw();
                    updateList();
                } catch (error) {
                    alert('Error al importar JSON: ' + error.message);
                }
                document.getElementById('fileInput').value = '';
            };
            reader.readAsText(file);
        }

        function updateList() {
            const list = document.getElementById('imageList');
            const countElement = document.getElementById('imageCount');
            list.innerHTML = '';
            
            images.forEach((img, idx) => {
                const div = document.createElement('div');
                if (img === selectedImage) {
                    div.classList.add('selected');
                }
                
                const inp = document.createElement('input');
                inp.type = 'text';
                inp.value = img.name;
                inp.onchange = () => {
                    img.name = inp.value;
                    draw();
                };
                
                const selBtn = document.createElement('button');
                selBtn.textContent = 'Seleccionar';
                selBtn.onclick = () => {
                    selectedImage = img;
                    updateList();
                    draw();
                };
                
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Eliminar';
                delBtn.onclick = () => {
                    // Liberar recursos de la imagen
                    if (img.img) {
                        img.img.src = '';
                    }
                    
                    const i = images.indexOf(img);
                    images.splice(i, 1);
                    if (selectedImage === img) selectedImage = null;
                    updateList();
                    draw();
                };
                
                div.appendChild(inp);
                if (img.isGif) {
                    const gifIndicator = document.createElement('span');
                    gifIndicator.textContent = 'GIF';
                    gifIndicator.classList.add('gif-indicator');
                    div.appendChild(gifIndicator);
                }
                div.appendChild(selBtn);
                div.appendChild(delBtn);
                list.appendChild(div);
            });
            
            countElement.textContent = `(${images.length})`;
        }

        function saveJSON() {
            if (images.length === 0) {
                alert('No hay imágenes para guardar');
                return;
            }
            
            const menuName = prompt('Nombre del menú:') || 'menu_default';
            const jsonData = {
                nombre: menuName,
                cuadros: images.map(img => ({
                    nombre: img.name,
                    x: img.x,
                    y: img.y,
                    alto: img.alto,
                    ancho: img.ancho,
                    url: img.url
                }))
            };
            
            const jsonStr = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${menuName}.json`;
            a.click();
        }

        // Inicializar
        setView('pc');
        selectTool('modificador');
        
        // Limpiar recursos al cerrar la página
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
