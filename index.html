<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editor de Menús para Juegos - Generador de JSON</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 10px; 
            background-color: #000; /* Fondo negro detrás del lienzo */
        }
        #container { 
            display: flex; 
            height: 100vh; 
            gap: 10px;
        }
        #canvasContainer { 
            border: 1px solid #333; 
            overflow: auto; 
            flex: 1; 
            max-width: calc(100vw - 320px);
            background-color: #fff; /* Lienzo blanco */
            box-shadow: 0 2px 10px rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        #canvas { 
            display: block; 
            border: 1px solid #ddd; 
            cursor: default;
            background-color: #f9f9f9;
        }
        #controls { 
            width: 300px; 
            padding: 15px; 
            overflow-y: auto;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(255,255,255,0.1);
        }
        .viewBtn { 
            margin: 5px 0; 
            padding: 8px 12px; 
            width: 100%;
            background-color: #4a6fa5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .viewBtn:hover {
            background-color: #3a5a8a;
        }
        #urlInput { 
            width: 100%; 
            margin-bottom: 5px; 
            padding: 8px; 
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button { 
            margin: 2px; 
            padding: 8px; 
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        #imageList div { 
            margin-bottom: 10px; 
            border: 1px solid #ddd; 
            padding: 8px; 
            border-radius: 4px;
            background-color: #f9f9f9;
        }
        #imageList input { 
            width: 150px; 
            margin-right: 5px; 
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .toolBtn { 
            width: 100%; 
            margin: 5px 0; 
        }
        input[type="radio"] { 
            margin-right: 5px; 
        }
        #fileInput { 
            display: none; 
        }
        .actionBtn { 
            width: 100%; 
            margin: 5px 0; 
            padding: 10px;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .actionBtn:hover {
            background-color: #4cae4c;
        }
        .gif-indicator {
            display: inline-block;
            background-color: #5cb85c;
            color: white;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }
        .coordinate-indicator {
            display: inline-block;
            background-color: #e74c3c;
            color: white;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }
        .rectangle-indicator {
            display: inline-block;
            background-color: #f39c12;
            color: white;
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
        }
        h3 {
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .selected {
            background-color: #e6f3ff;
            border-color: #4a90e2;
        }
        .section {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
        </div>
        <div id="controls">
            <div class="section">
                <h3>Vista</h3>
                <button class="viewBtn" onclick="setView('pc')">PC Horizontal (1920x1080)</button>
                <button class="viewBtn" onclick="setView('mobileH')">Móvil Horizontal (800x480)</button>
                <button class="viewBtn" onclick="setView('mobileV')">Móvil Vertical (480x800)</button>
            </div>
            
            <div class="section">
                <h3>Herramientas</h3>
                <label><input type="radio" name="tool" value="modificador" checked onchange="selectTool('modificador')"> Modificador</label><br>
                <label><input type="radio" name="tool" value="zoom" onchange="selectTool('zoom')"> Zoom de Imagen</label>
            </div>
            
            <div class="section">
                <h3>Añadir Elementos</h3>
                <input type="text" id="urlInput" placeholder="Colocar URL de la imagen (GIF, PNG, etc.)">
                <button onclick="loadImage()" style="width: 100%; margin-bottom: 10px;">Cargar Imagen</button>
                <button onclick="addRectangle()" style="width: 100%; background-color: #f39c12; color: white; margin-bottom: 5px;">Añadir Rectángulo</button>
                <button onclick="addCoordinate()" style="width: 100%; background-color: #e74c3c; color: white;">Añadir Coordenada (X)</button>
            </div>
            
            <div class="section">
                <h3>Elementos <span id="elementCount">(0)</span></h3>
                <div id="elementList"></div>
            </div>
            
            <button onclick="saveJSON()" class="actionBtn">Guardar JSON</button>
            <input type="file" id="fileInput" accept=".json" onchange="importJSON(event)">
            <button onclick="document.getElementById('fileInput').click()" class="actionBtn">Importar JSON</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let elements = []; // Ahora contiene tanto imágenes como coordenadas y rectángulos
        let currentView = 'pc';
        let zoom = 1;
        let selectedElement = null;
        let currentTool = 'modificador';
        let mode = 'none';
        let startX, startY;
        let logicalW, logicalH;
        let pivotRelX, pivotRelY, initialDist;
        let animationFrameId = null;

        const views = {
            'pc': { w: 1920, h: 1080 },
            'mobileH': { w: 800, h: 480 },
            'mobileV': { w: 480, h: 800 }
        };

        function selectTool(tool) {
            currentTool = tool;
            mode = 'none';
            canvas.style.cursor = 'default';
            draw();
        }

        function setView(viewName) {
            currentView = viewName;
            zoom = 1;
            updateCanvasSize();
            updateList();
        }

        function updateCanvasSize() {
            logicalW = views[currentView].w;
            logicalH = views[currentView].h;
            const displayW = logicalW * zoom;
            const displayH = logicalH * zoom;
            canvas.width = displayW;
            canvas.height = displayH;
            canvas.style.width = displayW + 'px';
            canvas.style.height = displayH + 'px';
            draw();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scale = zoom;
            return {
                x: (e.clientX - rect.left) / scale,
                y: (e.clientY - rect.top) / scale
            };
        }

        function getLogicalPosFromPercent(percentX, percentY) {
            return {
                x: (percentX / 100) * logicalW,
                y: (percentY / 100) * logicalH
            };
        }

        function getElementAt(mx, my) {
            for (let i = elements.length - 1; i >= 0; i--) {
                const element = elements[i];
                
                // Para coordenadas, verificamos si estamos cerca del punto
                if (element.type === 'coordinate') {
                    const { x: left, y: top } = getLogicalPosFromPercent(element.x, element.y);
                    const tolerance = 10; // Radio de tolerancia para seleccionar coordenadas
                    const distance = Math.sqrt((mx - left)**2 + (my - top)**2);
                    if (distance <= tolerance) {
                        return element;
                    }
                } 
                // Para imágenes y rectángulos, verificamos si estamos dentro del rectángulo
                else if (element.type === 'image' || element.type === 'rectangle') {
                    if (element.type === 'image' && (!element.img || !element.img.complete)) continue;
                    const { x: left, y: top } = getLogicalPosFromPercent(element.x, element.y);
                    const width = (element.ancho / 100) * logicalW;
                    const height = (element.alto / 100) * logicalH;
                    const right = left + width;
                    const bottom = top + height;
                    if (mx >= left && mx <= right && my >= top && bottom >= my) {
                        return element;
                    }
                }
            }
            return null;
        }

        function getHandleAt(element, mx, my) {
            // Las coordenadas no tienen handles de redimensionamiento
            if (element.type === 'coordinate') return null;
            
            const handleScreenSize = 10;
            const logicalHandleSize = handleScreenSize / zoom;
            const half = logicalHandleSize / 2;
            const { x: left, y: top } = getLogicalPosFromPercent(element.x, element.y);
            const width = (element.ancho / 100) * logicalW;
            const height = (element.alto / 100) * logicalH;
            const right = left + width;
            const bottom = top + height;

            if (mx >= left - half && mx <= left + half && my >= top - half && my <= top + half) return 'nw';
            if (mx >= right - half && mx <= right + half && my >= top - half && my <= top + half) return 'ne';
            if (mx >= left - half && mx <= left + half && my >= bottom - half && my <= bottom + half) return 'sw';
            if (mx >= right - half && mx <= right + half && my >= bottom - half && my <= bottom + half) return 'se';
            return null;
        }

        function getCursorForHandle(handle) {
            return (handle === 'nw' || handle === 'se') ? 'nwse-resize' : 'nesw-resize';
        }

        canvas.addEventListener('mousedown', (e) => {
            const pos = getMousePos(e);
            if (currentTool === 'zoom') {
                selectedElement = getElementAt(pos.x, pos.y);
                if (!selectedElement || selectedElement.type === 'coordinate') return; // No aplicar zoom a coordenadas
                mode = 'zoom';
                const { x: left, y: top } = getLogicalPosFromPercent(selectedElement.x, selectedElement.y);
                const width = (selectedElement.ancho / 100) * logicalW;
                const height = (selectedElement.alto / 100) * logicalH;
                pivotRelX = (pos.x - left) / width;
                pivotRelY = (pos.y - top) / height;
                startX = pos.x;
                startY = pos.y;
                initialDist = Math.sqrt((pos.x - startX)**2 + (pos.y - startY)**2);
                canvas.style.cursor = 'zoom-in';
            } else {
                selectedElement = getElementAt(pos.x, pos.y);
                if (!selectedElement) {
                    mode = 'none';
                    draw();
                    return;
                }
                
                // Para coordenadas, solo permitir arrastrar
                if (selectedElement.type === 'coordinate') {
                    mode = 'drag';
                    startX = pos.x;
                    startY = pos.y;
                } 
                // Para imágenes y rectángulos, permitir arrastrar y redimensionar
                else {
                    const handle = getHandleAt(selectedElement, pos.x, pos.y);
                    mode = handle || 'drag';
                    startX = pos.x;
                    startY = pos.y;
                }
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const pos = getMousePos(e);
            if (mode !== 'none') {
                if (currentTool === 'zoom' && mode === 'zoom') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const currentDist = Math.sqrt(dx*dx + dy*dy);
                    let scale = 1;
                    if (initialDist > 0) {
                        scale = currentDist / initialDist;
                    } else {
                        scale = 1 + (currentDist / 100);
                    }
                    if (scale < 0.1) scale = 0.1;
                    const oldWidth = (selectedElement.ancho / 100) * logicalW;
                    const oldHeight = (selectedElement.alto / 100) * logicalH;
                    const newWidth = oldWidth * scale;
                    const newHeight = oldHeight * scale;
                    const newLeft = startX - pivotRelX * newWidth;
                    const newTop = startY - pivotRelY * newHeight;
                    selectedElement.x = (newLeft / logicalW) * 100;
                    selectedElement.y = (newTop / logicalH) * 100;
                    selectedElement.ancho = (newWidth / logicalW) * 100;
                    selectedElement.alto = (newHeight / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    initialDist = currentDist;
                    draw();
                } else if (mode === 'drag') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedElement.x, selectedElement.y);
                    selectedElement.x = ((origLeft + dx) / logicalW) * 100;
                    selectedElement.y = ((origTop + dy) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'nw') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedElement.x, selectedElement.y);
                    const origRight = origLeft + (selectedElement.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedElement.alto / 100) * logicalH;
                    const newLeft = origLeft + dx;
                    const newTop = origTop + dy;
                    selectedElement.x = (newLeft / logicalW) * 100;
                    selectedElement.y = (newTop / logicalH) * 100;
                    selectedElement.ancho = ((origRight - newLeft) / logicalW) * 100;
                    selectedElement.alto = ((origBottom - newTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'ne') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedElement.x, selectedElement.y);
                    const origRight = origLeft + (selectedElement.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedElement.alto / 100) * logicalH;
                    const newRight = origRight + dx;
                    const newTop = origTop + dy;
                    selectedElement.y = (newTop / logicalH) * 100;
                    selectedElement.ancho = ((newRight - origLeft) / logicalW) * 100;
                    selectedElement.alto = ((origBottom - newTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'sw') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedElement.x, selectedElement.y);
                    const origRight = origLeft + (selectedElement.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedElement.alto / 100) * logicalH;
                    const newLeft = origLeft + dx;
                    const newBottom = origBottom + dy;
                    selectedElement.x = (newLeft / logicalW) * 100;
                    selectedElement.ancho = ((origRight - newLeft) / logicalW) * 100;
                    selectedElement.alto = ((newBottom - origTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                } else if (mode === 'se') {
                    const dx = pos.x - startX;
                    const dy = pos.y - startY;
                    const { x: origLeft, y: origTop } = getLogicalPosFromPercent(selectedElement.x, selectedElement.y);
                    const origRight = origLeft + (selectedElement.ancho / 100) * logicalW;
                    const origBottom = origTop + (selectedElement.alto / 100) * logicalH;
                    const newRight = origRight + dx;
                    const newBottom = origBottom + dy;
                    selectedElement.ancho = ((newRight - origLeft) / logicalW) * 100;
                    selectedElement.alto = ((newBottom - origTop) / logicalH) * 100;
                    startX = pos.x;
                    startY = pos.y;
                    draw();
                }
            } else {
                if (currentTool === 'zoom') {
                    const element = getElementAt(pos.x, pos.y);
                    canvas.style.cursor = (element && element.type !== 'coordinate') ? 'zoom-in' : 'default';
                } else {
                    const element = getElementAt(pos.x, pos.y);
                    if (element) {
                        if (element.type === 'coordinate') {
                            canvas.style.cursor = 'move';
                        } else {
                            const handle = getHandleAt(element, pos.x, pos.y);
                            if (handle) {
                                canvas.style.cursor = getCursorForHandle(handle);
                            } else {
                                canvas.style.cursor = 'move';
                            }
                        }
                    } else {
                        canvas.style.cursor = 'default';
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            mode = 'none';
            if (currentTool === 'zoom') {
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const pos = getMousePos(e);
            const element = getElementAt(pos.x, pos.y);
            if (!element || element.type === 'coordinate') return; // No aplicar zoom a coordenadas
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            zoom = Math.max(0.5, Math.min(3, zoom + delta));
            updateCanvasSize();
        });

        function draw() {
            // Cancelar el frame de animación anterior si existe
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Dibujar todos los elementos
            elements.forEach(element => {
                if (element.type === 'image') {
                    if (!element.img || !element.img.complete) return;
                    
                    const px = (element.x / 100) * logicalW * zoom;
                    const py = (element.y / 100) * logicalH * zoom;
                    const pw = (element.ancho / 100) * logicalW * zoom;
                    const ph = (element.alto / 100) * logicalH * zoom;
                    
                    ctx.drawImage(element.img, px, py, pw, ph);
                } else if (element.type === 'rectangle') {
                    const px = (element.x / 100) * logicalW * zoom;
                    const py = (element.y / 100) * logicalH * zoom;
                    const pw = (element.ancho / 100) * logicalW * zoom;
                    const ph = (element.alto / 100) * logicalH * zoom;
                    
                    // Dibujar rectángulo con color fijo (azul)
                    ctx.fillStyle = '#3498db';
                    ctx.fillRect(px, py, pw, ph);
                } else if (element.type === 'coordinate') {
                    const px = (element.x / 100) * logicalW * zoom;
                    const py = (element.y / 100) * logicalH * zoom;
                    
                    // Dibujar un punto rojo para la coordenada
                    ctx.fillStyle = '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(px, py, 5 * zoom, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Dibujar una cruz
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2 * zoom;
                    ctx.beginPath();
                    ctx.moveTo(px - 8 * zoom, py);
                    ctx.lineTo(px + 8 * zoom, py);
                    ctx.moveTo(px, py - 8 * zoom);
                    ctx.lineTo(px, py + 8 * zoom);
                    ctx.stroke();
                }
            });
            
            // Dibujar bordes y controles para el elemento seleccionado
            if (selectedElement) {
                if (selectedElement.type === 'image' || selectedElement.type === 'rectangle') {
                    const px = (selectedElement.x / 100) * logicalW * zoom;
                    const py = (selectedElement.y / 100) * logicalH * zoom;
                    const pw = (selectedElement.ancho / 100) * logicalW * zoom;
                    const ph = (selectedElement.alto / 100) * logicalH * zoom;
                    
                    ctx.strokeStyle = '#4a90e2';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(px, py, pw, ph);
                    
                    const hs = 10;
                    ctx.fillStyle = '#e74c3c';
                    ctx.fillRect(px - hs / 2, py - hs / 2, hs, hs);
                    ctx.fillRect(px + pw - hs / 2, py - hs / 2, hs, hs);
                    ctx.fillRect(px - hs / 2, py + ph - hs / 2, hs, hs);
                    ctx.fillRect(px + pw - hs / 2, py + ph - hs / 2, hs, hs);
                } else if (selectedElement.type === 'coordinate') {
                    const px = (selectedElement.x / 100) * logicalW * zoom;
                    const py = (selectedElement.y / 100) * logicalH * zoom;
                    
                    // Dibujar un círculo azul alrededor de la coordenada seleccionada
                    ctx.strokeStyle = '#4a90e2';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(px, py, 10 * zoom, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Programar el siguiente frame para animaciones
            animationFrameId = requestAnimationFrame(draw);
        }

        function loadImage() {
            const url = document.getElementById('urlInput').value.trim();
            if (!url) {
                alert('Por favor, introduce una URL válida');
                return;
            }
            
            const newElement = {
                type: 'image',
                name: `imagen ${elements.filter(e => e.type === 'image').length + 1}`,
                x: 40,
                y: 40,
                ancho: 20,
                alto: 20,
                url: url,
                img: new Image(),
                isGif: url.toLowerCase().endsWith('.gif')
            };
            
            newElement.img.crossOrigin = 'anonymous';
            newElement.img.onload = () => {
                draw();
                updateList();
            };
            newElement.img.onerror = () => {
                alert('Error al cargar la imagen. Verifica la URL y que no tenga restricciones CORS.');
                // Eliminar el elemento de la lista si falla la carga
                const index = elements.indexOf(newElement);
                if (index > -1) {
                    elements.splice(index, 1);
                    updateList();
                }
            };
            newElement.img.src = url;
            elements.push(newElement);
            selectedElement = newElement;
            document.getElementById('urlInput').value = '';
            draw();
            updateList();
        }

        function addRectangle() {
            const newElement = {
                type: 'rectangle',
                name: `rectángulo ${elements.filter(e => e.type === 'rectangle').length + 1}`,
                x: 40,
                y: 40,
                ancho: 20,
                alto: 20
            };
            
            elements.push(newElement);
            selectedElement = newElement;
            draw();
            updateList();
        }

        function addCoordinate() {
            const newElement = {
                type: 'coordinate',
                name: `coordenada ${elements.filter(e => e.type === 'coordinate').length + 1}`,
                x: 50, // Centro por defecto
                y: 50  // Centro por defecto
            };
            
            elements.push(newElement);
            selectedElement = newElement;
            draw();
            updateList();
        }

        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    if (!jsonData.nombre || !jsonData.cuadros || !Array.isArray(jsonData.cuadros)) {
                        throw new Error('Formato JSON inválido');
                    }
                    
                    // Limpiar elementos anteriores
                    elements.forEach(element => {
                        if (element.img) {
                            element.img.src = ''; // Liberar recursos
                        }
                    });
                    
                    elements = [];
                    selectedElement = null;
                    
                    // Cargar nuevos elementos
                    jsonData.cuadros.forEach(cuadro => {
                        // Determinar si es una imagen, rectángulo o coordenada
                        if (cuadro.url) {
                            // Es una imagen
                            const element = {
                                type: 'image',
                                name: cuadro.nombre || `imagen ${elements.filter(e => e.type === 'image').length + 1}`,
                                x: cuadro.x || 0,
                                y: cuadro.y || 0,
                                ancho: cuadro.ancho || 20,
                                alto: cuadro.alto || 20,
                                url: cuadro.url || '',
                                img: new Image(),
                                isGif: (cuadro.url || '').toLowerCase().endsWith('.gif')
                            };
                            
                            element.img.crossOrigin = 'anonymous';
                            element.img.onload = () => {
                                draw();
                                updateList();
                            };
                            element.img.onerror = () => {
                                console.warn(`No se pudo cargar la imagen: ${element.url}`);
                            };
                            element.img.src = element.url;
                            elements.push(element);
                        } else if (cuadro.ancho && cuadro.alto) {
                            // Es un rectángulo
                            const element = {
                                type: 'rectangle',
                                name: cuadro.nombre || `rectángulo ${elements.filter(e => e.type === 'rectangle').length + 1}`,
                                x: cuadro.x || 0,
                                y: cuadro.y || 0,
                                ancho: cuadro.ancho || 20,
                                alto: cuadro.alto || 20
                            };
                            elements.push(element);
                        } else {
                            // Es una coordenada
                            const element = {
                                type: 'coordinate',
                                name: cuadro.nombre || `coordenada ${elements.filter(e => e.type === 'coordinate').length + 1}`,
                                x: cuadro.x || 0,
                                y: cuadro.y || 0
                            };
                            elements.push(element);
                        }
                    });
                    
                    draw();
                    updateList();
                } catch (error) {
                    alert('Error al importar JSON: ' + error.message);
                }
                document.getElementById('fileInput').value = '';
            };
            reader.readAsText(file);
        }

        function updateList() {
            const list = document.getElementById('elementList');
            const countElement = document.getElementById('elementCount');
            list.innerHTML = '';
            
            elements.forEach((element, idx) => {
                const div = document.createElement('div');
                if (element === selectedElement) {
                    div.classList.add('selected');
                }
                
                const inp = document.createElement('input');
                inp.type = 'text';
                inp.value = element.name;
                inp.onchange = () => {
                    element.name = inp.value;
                    draw();
                };
                
                const selBtn = document.createElement('button');
                selBtn.textContent = 'Seleccionar';
                selBtn.onclick = () => {
                    selectedElement = element;
                    updateList();
                    draw();
                };
                
                const delBtn = document.createElement('button');
                delBtn.textContent = 'Eliminar';
                delBtn.onclick = () => {
                    // Liberar recursos de la imagen si es necesario
                    if (element.img) {
                        element.img.src = '';
                    }
                    
                    const i = elements.indexOf(element);
                    elements.splice(i, 1);
                    if (selectedElement === element) selectedElement = null;
                    updateList();
                    draw();
                };
                
                div.appendChild(inp);
                if (element.type === 'image' && element.isGif) {
                    const gifIndicator = document.createElement('span');
                    gifIndicator.textContent = 'GIF';
                    gifIndicator.classList.add('gif-indicator');
                    div.appendChild(gifIndicator);
                } else if (element.type === 'rectangle') {
                    const rectIndicator = document.createElement('span');
                    rectIndicator.textContent = 'R';
                    rectIndicator.classList.add('rectangle-indicator');
                    div.appendChild(rectIndicator);
                } else if (element.type === 'coordinate') {
                    const coordIndicator = document.createElement('span');
                    coordIndicator.textContent = 'X';
                    coordIndicator.classList.add('coordinate-indicator');
                    div.appendChild(coordIndicator);
                }
                div.appendChild(selBtn);
                div.appendChild(delBtn);
                list.appendChild(div);
            });
            
            countElement.textContent = `(${elements.length})`;
        }

        function saveJSON() {
            if (elements.length === 0) {
                alert('No hay elementos para guardar');
                return;
            }
            
            const menuName = prompt('Nombre del menú:') || 'menu_default';
            const jsonData = {
                nombre: menuName,
                cuadros: elements.map(element => {
                    if (element.type === 'image') {
                        return {
                            nombre: element.name,
                            x: element.x,
                            y: element.y,
                            alto: element.alto,
                            ancho: element.ancho,
                            url: element.url
                        };
                    } else if (element.type === 'rectangle') {
                        return {
                            nombre: element.name,
                            x: element.x,
                            y: element.y,
                            alto: element.alto,
                            ancho: element.ancho
                        };
                    } else {
                        return {
                            nombre: element.name,
                            x: element.x,
                            y: element.y
                            // Sin ancho ni alto para coordenadas
                        };
                    }
                })
            };
            
            const jsonStr = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${menuName}.json`;
            a.click();
        }

        // Inicializar
        setView('pc');
        selectTool('modificador');
        
        // Limpiar recursos al cerrar la página
        window.addEventListener('beforeunload', () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        });
    </script>
</body>
</html>
